\documentclass[a4paper]{article}
\usepackage{hyperref}
\usepackage{appendix}
\usepackage{color}
\usepackage{listings}
\usepackage{setspace}
\definecolor{Code}{rgb}{0,0,0}
\definecolor{Decorators}{rgb}{0.5,0.5,0.5}
\definecolor{Numbers}{rgb}{0.5,0,0}
\definecolor{MatchingBrackets}{rgb}{0.25,0.5,0.5}
\definecolor{Keywords}{rgb}{0,0,1}
\definecolor{self}{rgb}{0,0,0}
\definecolor{Strings}{rgb}{0,0.63,0}
\definecolor{Comments}{rgb}{0,0.63,1}
\definecolor{Backquotes}{rgb}{0,0,0}
\definecolor{Classname}{rgb}{0,0,0}
\definecolor{FunctionName}{rgb}{0,0,0}
\definecolor{Operators}{rgb}{0,0,0}
\definecolor{Background}{rgb}{0.98,0.98,0.98}
\lstdefinelanguage{Python}{
numbers=left,
numberstyle=\footnotesize,
numbersep=1em,
xleftmargin=1em,
framextopmargin=2em,
framexbottommargin=2em,
showspaces=false,
showtabs=false,
showstringspaces=false,
frame=l,
tabsize=4,
% Basic
basicstyle=\ttfamily\small\setstretch{1},
backgroundcolor=\color{Background},
% Comments
commentstyle=\color{Comments}\slshape,
% Strings
stringstyle=\color{Strings},
morecomment=[s][\color{Strings}]{"""}{"""},
morecomment=[s][\color{Strings}]{'''}{'''},
% keywords
morekeywords={import,from,class,def,for,while,if,is,in,elif,else,not,and,or,print,break,continue,return,True,False,None,access,as,,del,except,exec,finally,global,import,lambda,pass,print,raise,try,assert},
keywordstyle={\color{Keywords}\bfseries},
% additional keywords
morekeywords={[2]@invariant,pylab,numpy,np,scipy},
keywordstyle={[2]\color{Decorators}\slshape},
emph={self},
emphstyle={\color{self}\slshape},
%
}

\begin{document}
\title{Code Organisation for Research Software}
\author{Oxford Research Software Engineering Group}
\maketitle

\section{Introduction}
You may well have encountered problems associated with developing code with no structure in mind. When all of your program is in a single file it becomes hard to find the part you need to change to fix a bug. When you do make a change, it's difficult to understand all of the ramifications of that change, and whether you have changed everything that needs updating.

In this course, you'll learn some basics of code organisation. Firstly you'll learn about some concepts that software engineers use when thinking about how to find parts of a big chunk of code to break out into separate routines, procedures or functions (for the most part, those are words that we're using interchangably in this handout). Then you'll be given practical steps to apply those concepts and organise your code.

With code organised into distinct functions that serve different purposes, you will then learn to separate these functions out into their own files, and import them where you need to use them. This lets you reuse the same functions across different projects, increasing the impact of your software and your efficiency as a programmer.

Finally, once you've learned how to import code from other files, you'll learn how to import code from libraries written by other authors, further increasing your efficiency by allowing you to stand on the shoulders of other programming giants.

All of the examples in this handout use the Python programming language.

\section{Designing Well-Organised Software}

There are no hard-and-fast rules in code organisation, so we can't just teach you something like ``split every ten instructions into their own function''. What we'll do is show you the the goals we have and the principles we follow to support those goals. Apply those principles to organising your own projects.

\subsection{Reduce duplication}

A good rule of thumb in organising your code is to reduce the number of times you describe the same procedure or algorithm to the computer. The more times you duplicate the same instructions in your software, the more chances there are that one of them can be erroneous. This is particularly true when you come to make changes. If there are, for example, three places where you define the routine for reading input files, and only remember to update two of them, then your software will exhibit inconsistent behaviour depending on which is used.

On the other hand, if these three routines are replaced by three calls to a single shared procedure, then all three will get the new behaviour whenever you update the routine. Additionally, this procedure can be used in other contexts where the same input files will be read.

\subsection {Create cohesive routines}

We don't greedily look for duplicated segments of code and split them into routines. The components of our software need to have \textit{cohesion}. By this we mean that they need to have identifiable purposes and behaviour. A procedure that reads data from a \textsc{fits} file into an array can clearly be used in any program that needs to work with \textsc{fits} files. A procedure that reads data from a \textsc{fits} file into an array and writes the current time to the console is not as easy to work with.

A convenient heuristic for measuring cohesion is ``do one thing well''. A function that does multiple things is not cohesive. A function that does a small part of something is not cohesive. This is hard to be absolutist about. What one person thinks of as a single function may be to another a small part of something useful, and to another a sequence of multiple steps. Depending on what you're trying to do, ``open a file for reading'' may be a task in itself, or a small part of ``read in the initial state of the simulation''. However, ``read the data in the middle third of the file'' is probably no use to anybody.

What this amounts to is that there should be \textit{some} level of abstraction at which the function or routine you're creating can be seen to ``do one thing''. Going back to the example of reading a file, it is certainly true that ``open the file'' is a single operation. But if you put the sequence together ``open the file, create an array, read each line of the file into the array, close the file'', that could also be the recipe for a single operation ``read the input data''. And like any recipe, the order in which you perform the steps matter. Therefore this higher-level routine that is made of a specific sequence of other steps is itself a cohesive operation, so is a good candidate for being its own routine.

\subsection {Remove unnecessary coupling}

Two train carriages are coupled if they are joined by a connector, with the result that exerting a force on one of them causes the other to move. By analogy, two code functions are coupled if they are joined in such a way that trying to use one of them will have an effect on uses of the other.

Sometimes coupling is necessary and even welcome: you can't close a file until you've opened it, for example, so open and close are coupled routines. In this case, the coupling is inherent in the problem being solved, which makes it easy to understand and perhaps even expected. The problems come when routines are coupled because of the way that they are implemented, but the coupling would not be expected based on an understanding of what the routine is supposed to do.

This points to an important design principle in creating routines: you should be able to understand what a routine does based on its \textit{declaration} (its name, parameters, and documentation) without having to read its \textit{definition} (the list of statements in the routine). If you can, then that understanding stands in for reading a whole chunk of code and makes your program easier to follow.

Surprising coupling frustrates that simplified understanding---it stops you from working out how a routine works without studying its implementation. If you can't calculate the Fourier Transform of a signal using a function called \texttt{calculateFourier()}, and the reason is that the transform routine doesn't work until you've set the printer into colour mode, you're going to have a frustrating time tracking down and fixing that problem. If at some point someone fixes that problem, and now you find that despite calculating a Fourier transform your printouts are still in monochrome, you have another problem to solve.

Coupling also restricts reuse. If one routine is coupled to another, it can't be used in another project without bringing that other routine along too, and making the programmer use both in a supported way. If that second routine also has coupling to other parts of the code, they're also coming along for the ride.

The book ``Code Complete, 2nd Edition'' by Steve McConnell\cite{cc2e} lists a few forms of coupling.

\begin{itemize}
\item Basic Parameter Coupling. A function calls another function, passing parameters like numbers and strings.
\item Simple Object Coupling. A function creates, and uses, an instance of an object.
\item Object-Parameter Coupling. A function calls another function, passing an instance of another object.
\item Control Flag Coupling. A function passes a Boolean switch to another function, telling it how to work.
\item Global Data Coupling. One function operates on data that has been modified by another function.
\item Internal Behaviour Coupling. A function makes use of knowledge of the way another function works, beyond the expectations that could reasonably be derived from the function documentation.
\end{itemize}

McConnell suggests that the first two forms of coupling are innocuous, and the rest potentially problematic. More simply, greater coupling means more opaque operation and less chance for re-use, so our maxim for creating reusable routines can be ``high cohesiveness, low coupling''.

\subsection{Remove ``smells''}

Notice in the last section that McConnell said that the forms of coupling identified were \emph{potentially} problematic. There are no hard and fast rules in design, which is a combination of engineering principles and aesthetics. There is no algorithm I can give you for good software design, and no quantitative metric. I can say that you should avoid global variables, but I can also say that you should avoid contorting your code until it's unreadable in the name of excising a global variable.

I could tell you to prefer short functions, but also to prefer making your algorithms explicit and obvious even where that makes functions longer. That means I can't just say ``ten lines per function, and no more''. Reduce coupling, but don't decouple two things that clearly belong together. And so on.

Software engineers talk about code ``smells''\cite{chsmell}. The idea is that something that smells weird isn't necessarily wrong, but definitely warrants further investigation. Good code organisation removes smells, either by fixing the cause of the smell (e.g. reorganising a long function into several shorter ones) or by justifying the existing organisation clearly enough that any concerns are assuaged. That justification can come in the form of an intuitive interface that makes it obvious how to use the functions, and documentation that explains the design choices made and why alternatives were rejected.

\section{Organising Existing Code}

In this section, we'll take a small program written in Python and and re-organise it to improve readability. The code models the incidence of a highly-transmissible disease through a University population; a timely example when this was written. Each of the sections explores a different aspect of the program and suggests an improving change. The original source can be seen in Appendix \ref{code-appendix}; the final version on Github at \url{https://github.com/OxfordRSE/covid-19-model}.

\begin{appendices}
\section{Original Simulation Code\label{code-appendix}}

\lstinputlisting[language=Python]{original_code.py}

\end{appendices}

\begin{thebibliography}{9}
  \bibitem{cc2e} McConnell, Steve, \textit{Code Complete, 2nd Edition}. Microsoft Press, 2004.
  \bibitem{chsmell} Attwood, Jeff, \textit{Code Smells}. \url{https://blog.codinghorror.com/code-smells/}, accessed 2020--07--10.
\end{thebibliography}
\end{document}
